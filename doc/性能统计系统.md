# 性能统计系统

> **相关源文件**
> * [p10/10_sorting_comparison.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp)

## 目的与范围

性能统计系统是项目十中的“实证测量框架”，用于收集、计算并展示排序算法的性能特征。系统在多组数据规模上对每种算法统计三类关键指标（执行时间、比较次数、交换/移动次数），从而支持对算法效率进行定量对比。实现上，系统在各排序算法关键操作点进行计数埋点，运行时采集统计信息，并将结果按表格格式输出。

如需了解排序算法本身的实现，请参见 [Sorting Algorithm Implementations](排序算法实现说明.md)。如需了解项目十整体架构，请参见 [Project 10: Sorting Algorithm Comparison](项目十-排序算法比较.md)。

**来源：** [p10/10_sorting_comparison.cpp L1-L26](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L1-L26)

 [p10/10_sorting_comparison.cpp L373-L448](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L373-L448)

---

## 核心数据结构：SortStatistics

`SortStatistics` 结构体是单次排序测量过程中所有指标的核心容器。

```

```

### 字段说明

| 字段 | 类型 | 用途 | 范围 |
| --- | --- | --- | --- |
| `algorithm_name` | `char[32]` | 算法可读标识（中文） | 最多 31 字符 + 终止符 |
| `compare_count` | `long long` | 元素比较总次数 | 大规模数据时可达 ~10^10 |
| `swap_count` | `long long` | 元素交换或移动总次数 | 大规模数据时可达 ~10^10 |
| `time_elapsed_ms` | `double` | 执行耗时（毫秒） | 由 `clock()` 差值计算 |

构造函数（[p10/10_sorting_comparison.cpp L19-L25](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L19-L25)）会将数值字段初始化为 0，并将名称缓冲区置为空串，以保证每次测量从干净状态开始。

**来源：** [p10/10_sorting_comparison.cpp L12-L26](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L12-L26)

---

## 计时机制

### 基于 clock() 的时间测量

系统使用底层 `clock()` 进行较高精度的时间测量：

```

```

### 实现细节

该计时机制以微秒级的时钟刻度工作：

* **clock 声明**：见 [p10/10_sorting_comparison.cpp L8-L9](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L8-L9)，引入 C 的 `clock()` 函数
* **时钟频率**：`kClocksPerSec = 1000000` 表示在 Linux/WSL2 下使用 POSIX 风格的微秒 tick
* **时间换算**：见 [p10/10_sorting_comparison.cpp L398](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L398-L398)，将 tick 转换为毫秒：`(end - start) * 1000.0 / kClocksPerSec`

该方法精度足以测量到亚毫秒级别，并保持在类 Unix 系统上的可移植性。

**来源：** [p10/10_sorting_comparison.cpp L8-L10](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L8-L10)

 [p10/10_sorting_comparison.cpp L394-L398](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L394-L398)

---

## 计数埋点（Instrumentation）

### 埋点模式

每个排序算法都会在关键操作点对 `SortStatistics` 计数器进行递增，所有算法遵循一致的埋点模式：

```

```

### 比较次数计数示例

**BubbleSort**：[p10/10_sorting_comparison.cpp L85](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L85-L85) 在内层循环每次比较前递增：

```

```

**SelectionSort**：[p10/10_sorting_comparison.cpp L107](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L107-L107) 在寻找最小值过程中计数：

```

```

**QuickSort**：[p10/10_sorting_comparison.cpp L178](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L178-L178) 在分区过程中递增：

```

```

### 交换/移动次数计数示例

**BubbleSort**：[p10/10_sorting_comparison.cpp L88-L89](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L88-L89) 统计真实交换次数：

```

```

**MergeSort**：[p10/10_sorting_comparison.cpp L282](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L282-L282) 将“合并过程中的元素移动”计为“交换”：

```

```

**RadixSort**：[p10/10_sorting_comparison.cpp L362](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L362-L362) 统计按位分配带来的移动：

```

```

### 特殊情况

* **RadixSort**：非比较排序，因此 `compare_count` 始终为 0，仅 `swap_count` 具有意义
* **InsertionSort/ShellSort**：将元素“移动/后移”按交换计数（[p10/10_sorting_comparison.cpp L132-L133](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L132-L133)）
* **HeapSort**：统计既包含建堆阶段也包含排序阶段（[p10/10_sorting_comparison.cpp L225-L226](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L225-L226) 与 [p10/10_sorting_comparison.cpp L245-L246](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L245-L246)）

**来源：** [p10/10_sorting_comparison.cpp L78-L98](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L78-L98)

 [p10/10_sorting_comparison.cpp L100-L119](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L100-L119)

 [p10/10_sorting_comparison.cpp L172-L194](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L172-L194)

 [p10/10_sorting_comparison.cpp L265-L298](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L265-L298)

 [p10/10_sorting_comparison.cpp L323-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L323-L371)

---

## 测试数据生成

### 随机数组生成

`GenerateRandomArray()` 用可控随机性生成测试数据集：

```

```

### 伪随机数生成器（PRNG）实现

自定义 PRNG 使用线性同余发生器（LCG）：

* **算法**：见 [p10/10_sorting_comparison.cpp L51-L55](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L51-L55)，实现 `NextRand(seed)`
* **公式**：`seed = seed * 1103515245u + 12345u`
* **输出**：`(seed / 65536u) % 32768u` 生成 15 位值
* **组合**：将两个 15 位值通过左移与 XOR 组合，生成 30 位值
* **范围**：最终对 1000000 取模，得到 [0, 999999] 的整数

### 可复现性

固定种子（123456789u）保证 **跨运行的确定性测试数据**。这对公平比较至关重要：同一次测试中各算法面对相同输入，消除由于输入分布差异带来的波动。

**来源：** [p10/10_sorting_comparison.cpp L51-L74](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L51-L74)

---

## 测试执行流程

### 单算法执行

`ExecuteSort()` 封装了对单个算法的完整测量流程：

```

```

### 关键步骤

1. **数据隔离**：见 [p10/10_sorting_comparison.cpp L385-L389](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L385-L389)，拷贝原数组，避免算法之间互相影响
2. **统计初始化**：见 [p10/10_sorting_comparison.cpp L391-L392](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L391-L392)，构造新的 `SortStatistics` 并设置算法名
3. **计时区间**：见 [p10/10_sorting_comparison.cpp L394-L396](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L394-L396)，在执行前后读取 `clock()`
4. **时间换算**：见 [p10/10_sorting_comparison.cpp L398](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L398-L398)，将 tick 转换为毫秒
5. **格式化输出**：见 [p10/10_sorting_comparison.cpp L400-L405](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L400-L405)，输出算法名、耗时、比较次数与交换次数（固定精度）
6. **内存释放**：见 [p10/10_sorting_comparison.cpp L407](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L407-L407)，释放工作数组

**来源：** [p10/10_sorting_comparison.cpp L383-L408](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L383-L408)

---

## 批量性能测试

### 多算法对比

`RunPerformanceTest()` 会在同一份数据上依次执行 8 种算法，并输出对比表：

```

```

### 算法入口表

`AlgorithmEntry` 结构体（[p10/10_sorting_comparison.cpp L377-L381](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L377-L381)）将中文算法名映射到函数指针：

| Index | 中文名称 | 函数指针 | 算法 |
| --- | --- | --- | --- |
| 0 | 冒泡排序 | `BubbleSort` | Bubble Sort |
| 1 | 选择排序 | `SelectionSort` | Selection Sort |
| 2 | 直接插入排序 | `InsertionSort` | Insertion Sort |
| 3 | 希尔排序 | `ShellSort` | Shell Sort |
| 4 | 快速排序 | `QuickSort` | Quick Sort |
| 5 | 堆排序 | `HeapSort` | Heap Sort |
| 6 | 归并排序 | `MergeSort` | Merge Sort |
| 7 | 基数排序 | `RadixSort` | Radix Sort |

### 输出格式

输出表格格式位于 [p10/10_sorting_comparison.cpp L435-L438](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L435-L438)，显示：

```
============================================================
数据规模: 10000
排序算法    时间        比较次数    交换次数
------------------------------------------------------------
冒泡排序    123.456 ms  49995000    24997500
...
============================================================
```

每个算法通过 `ExecuteSort()` 生成一行结果，从而保证列对齐与 3 位小数的统一格式。

**来源：** [p10/10_sorting_comparison.cpp L410-L448](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L410-L448)

 [p10/10_sorting_comparison.cpp L425-L433](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L425-L433)

---

## 多规模测试框架

### 标准测试规模

系统在 4 组预设规模上测试，以揭示复杂度特征：

```

```

### 执行顺序

当用户选择进行完整性能对比（[p10/10_sorting_comparison.cpp L566-L577](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L566-L577)）时：

1. **固定规模**：总会运行 100、1000、10000、100000 四组测试
2. **自定义规模**：若用户输入规模不在上述四组中，则额外补跑该规模
3. **顺序执行**：每个规模完整跑完后再进入下一规模
4. **相同随机种子**：同一规模下各算法使用相同随机数据（确定性 PRNG）

### 规模选择理由

| 规模 | 目的 | 预期表现 |
| --- | --- | --- |
| 100 | 基线 | 所有算法都很快，便于观察固定开销 |
| 1,000 | 拉开差距 | O(N²) 相比 O(N log N) 更明显变慢 |
| 10,000 | 压力测试 | O(N²) 可能需数秒，层级差异更清晰 |
| 100,000 | 实用上限 | 冒泡/选择不现实，高效算法仍可响应 |

10 倍的几何递增会放大复杂度差异：O(N²) 算法从 1000 到 10000 会慢 100 倍，而 O(N log N) 算法通常只慢约 13 倍左右。

**来源：** [p10/10_sorting_comparison.cpp L568-L577](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L568-L577)

---

## 输出显示系统

### 控制台格式化

系统使用 `std::cout` 的格式化标志实现列对齐输出：

```

```

### 格式化配置

* **固定小数格式**：见 [p10/10_sorting_comparison.cpp L400](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L400-L400)，避免科学计数法
* **精度**：见 [p10/10_sorting_comparison.cpp L401](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L401-L401)，耗时保留 3 位小数
* **制表符分隔**：见 [p10/10_sorting_comparison.cpp L402-L405](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L402-L405)，使用 `\t` 对齐列
* **单位**：时间以 " ms" 作为后缀明确标识

### 示例输出结构

**单算法测试**（[p10/10_sorting_comparison.cpp L509-L513](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L509-L513)）：

```
算法: 快速排序
数据规模: 10000
执行时间: 1.234 ms
比较次数: 138517
交换次数: 9863
```

**对比表**（[p10/10_sorting_comparison.cpp L437-L438](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L437-L438)）：

```
排序算法        时间            比较次数        交换次数
------------------------------------------------------------
快速排序        1.234 ms        138517          9863
```

该表格格式便于快速直观地对比各算法的指标差异。

**来源：** [p10/10_sorting_comparison.cpp L400-L405](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L400-L405)

 [p10/10_sorting_comparison.cpp L507-L513](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L507-L513)

---

## 与主菜单系统的集成

### 用户交互流程

性能统计系统与菜单交互界面集成于 [p10/10_sorting_comparison.cpp L518-L581](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L518-L581)：

```

```

### 菜单选项

菜单（[p10/10_sorting_comparison.cpp L450-L465](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L450-L465)）提供：

* 选项 1-8：测试单个排序算法
* 选项 9：退出程序

单算法测试完成后，系统会提示（[p10/10_sorting_comparison.cpp L563-L577](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L563-L577)）："是否对所有算法进行性能比较测试？(y/n)"

若用户输入 'y' 或 'Y'，则 `RunPerformanceTest()` 将执行四个标准规模测试，并在“用户输入规模与标准规模不同”时额外补跑该规模。

### 输入校验

* **菜单选择校验**：见 [p10/10_sorting_comparison.cpp L540-L543](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L540-L543)，校验范围 [1-9]
* **数据规模校验**：见 [p10/10_sorting_comparison.cpp L554-L557](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L554-L557)，校验范围 [1-1000000]
* **错误处理**：见 [p10/10_sorting_comparison.cpp L528-L532](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L528-L532)，对非数字输入调用 `ClearInputBuffer()`

**来源：** [p10/10_sorting_comparison.cpp L518-L581](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L518-L581)

 [p10/10_sorting_comparison.cpp L450-L465](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L450-L465)

---

## 内存管理

### 分配与释放模式

系统通过谨慎的动态内存管理避免泄漏：

```

```

### 分配点

1. **测试数据**：在 [p10/10_sorting_comparison.cpp L418](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L418-L418) 与 [p10/10_sorting_comparison.cpp L475](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L475-L475) 分配原始数组
2. **工作拷贝**：在 [p10/10_sorting_comparison.cpp L385](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L385-L385) 为每个算法分配拷贝，避免互相影响
3. **算法临时缓冲**：* MergeSort：在 [p10/10_sorting_comparison.cpp L318](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L318-L318) 分配临时合并数组 * RadixSort：在 [p10/10_sorting_comparison.cpp L339](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L339-L339) 分配输出数组

### 释放点

1. **测试结束清理**：在 [p10/10_sorting_comparison.cpp L447](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L447-L447) 与 [p10/10_sorting_comparison.cpp L515](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L515-L515) 删除原始数组
2. **工作拷贝清理**：在 [p10/10_sorting_comparison.cpp L407](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L407-L407) 每次排序后删除拷贝
3. **算法清理**：* MergeSort：在 [p10/10_sorting_comparison.cpp L320](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L320-L320) 删除临时数组 * RadixSort：在 [p10/10_sorting_comparison.cpp L370](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L370-L370) 删除输出数组

所有分配均使用 `new[]`，并与 `delete[]` 成对出现，确保数组内存正确释放。

**来源：** [p10/10_sorting_comparison.cpp L318-L320](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L318-L320)

 [p10/10_sorting_comparison.cpp L339-L370](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L339-L370)

 [p10/10_sorting_comparison.cpp L385-L407](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L385-L407)

 [p10/10_sorting_comparison.cpp L418-L447](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L418-L447)
