# 算法参考

> **相关源文件**
> * [p10/10_sorting_comparison.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp)
> * [p3/maze_game.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp)
> * [p7/p7.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp)
> * [p8/p8.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp)

## 目的与范围

本页提供 DataStruct 仓库内全部算法的跨项目综合参考，涵盖图遍历算法（DFS）、图优化算法（Prim 最小生成树）、贪心优化（哈夫曼式合并）以及比较类与非比较类排序算法。每种算法都给出时间与空间复杂度、关键实现细节以及对应源码位置，便于对照理解与复习。

如需查看这些算法所依赖的数据结构实现，请参见 [Data Structures Reference](数据结构参考.md)。如需查看带有使用示例的单个项目文档，请参见 [Projects Overview](项目概览.md)。

---

## 算法分类

### 按类别的算法体系

```

```

**来源：** [p3/maze_game.cpp L113-L150](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp#L113-L150)

 [p7/p7.cpp L74-L111](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L74-L111)

 [p8/p8.cpp L227-L311](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L227-L311)

 [p10/10_sorting_comparison.cpp L76-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L76-L371)

---

## 图算法

### DFS 回溯（迷宫寻路）

**算法：** `Maze::DFS(int x, int y)`
**实现位置：** [p3/maze_game.cpp L113-L150](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp#L113-L150)

**用途：** 使用带回溯的深度优先搜索，在基于网格的迷宫中寻找从起点到终点的一条路径。

#### 算法结构

```

```

#### 关键实现细节

| 方面 | 实现 | 位置 |
| --- | --- | --- |
| 已访问标记 | `bool visited_[kMaxSize][kMaxSize]` | [p3/maze_game.cpp L39](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp#L39-L39) |
| 路径存储 | `Position path_[kMaxSize * kMaxSize]` | [p3/maze_game.cpp L40](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp#L40-L40) |
| 方向向量 | `const int kDx[4] = {1,0,-1,0}; kDy[4] = {0,1,0,-1}` | [p3/maze_game.cpp L10-L11](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp#L10-L11) |
| 合法性检查 | `IsValid(x,y)`：边界检查 + `maze_[x][y]==0` + `!visited_[x][y]` | [p3/maze_game.cpp L102-L105](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp#L102-L105) |
| 终止条件 | `x == end_x_ && y == end_y_` | [p3/maze_game.cpp L115](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp#L115-L115) |
| 回溯动作 | `visited_[x][y] = false; path_length_--` | [p3/maze_game.cpp L143-L148](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp#L143-L148) |

#### 复杂度分析

* **时间复杂度：** O(V + E)，其中 V = 行数 × 列数（网格单元数），E = 4V（网格图最大边数） * 最坏情况：O(行数 × 列数)，需要探索整个迷宫 * 由于 `visited_` 数组的限制，每个单元最多访问一次
* **空间复杂度：** O(行数 × 列数) 用于 `visited_` 数组与路径存储 * 递归调用栈最坏深度：O(行数 × 列数)（完全遍历时）

**来源：** [p3/maze_game.cpp L1-L150](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp#L1-L150)

---

### Prim 算法（最小生成树）

**算法：** `PowerGridSystem::ConstructPrimMST()`
**实现位置：** [p8/p8.cpp L227-L311](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L227-L311)

**用途：** 使用 Prim 贪心算法，为带权无向图构造最小生成树（MST）。

#### 算法数据流

```

```

#### 关键数据结构

| 结构 | 用途 | 类型 | 位置 |
| --- | --- | --- | --- |
| `adj_matrix_[i][j]` | 顶点之间的边权 | `int[kMaxNodes][kMaxNodes]` | [p8/p8.cpp L41](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L41-L41) |
| `lowcost[i]` | 从 MST 到顶点 i 的最小连接边权 | `int[kMaxNodes]` | [p8/p8.cpp L250](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L250-L250) |
| `closest[i]` | 与顶点 i 最近的 MST 内顶点 | `int[kMaxNodes]` | [p8/p8.cpp L251](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L251-L251) |
| `visited[i]` | 顶点 i 是否已加入 MST | `bool[kMaxNodes]` | [p8/p8.cpp L252](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L252-L252) |
| `mst_edges_[i]` | MST 边集合数组 | `Edge[kMaxNodes]` | [p8/p8.cpp L45](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L45-L45) |

#### 算法步骤

1. **初始化**（[p8/p8.cpp L255-L262](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L255-L262)）：将 `lowcost[i]` 设为起始顶点到 i 的边权，标记起始顶点为已访问
2. **主循环**（[p8/p8.cpp L268-L308](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L268-L308)）：重复 n-1 次： * 在未访问顶点中选取 `lowcost[k]` 最小的顶点 k（[p8/p8.cpp L270-L281](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L270-L281)） * 将边 `{closest[k], k}` 加入 MST（[p8/p8.cpp L292-L295](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L292-L295)） * 对 k 的相邻点更新 `lowcost` 与 `closest`（[p8/p8.cpp L300-L307](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L300-L307)）
3. **结果落盘**（[p8/p8.cpp L310](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L310-L310)）：设置 `is_mst_created_ = true`

#### 复杂度分析

* **时间复杂度：** O(V²)，其中 V 为顶点数 * 外层循环：V-1 次（[p8/p8.cpp L268](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L268-L268)） * 内层最小值搜索：每次 O(V)（[p8/p8.cpp L274-L281](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L274-L281)） * 更新步骤：每次 O(V)（[p8/p8.cpp L300-L307](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L300-L307)） * 总计：O(V × (V + V)) = O(V²)
* **空间复杂度：** 邻接矩阵 O(V²) + 辅助数组 O(V) = O(V²)

**备注：** 若使用优先队列可将复杂度优化到 O((V+E) log V)，但当前实现为简化起见采用邻接矩阵。

**来源：** [p8/p8.cpp L227-L311](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L227-L311)

 [p8/p8.cpp L1-L48](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L1-L48)

---

## 贪心算法

### 哈夫曼式合并（最小代价木材切割）

**算法：** 基于 `HeapPop()` 与 `HeapPush()` 的主循环
**实现位置：** [p7/p7.cpp L74-L111](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L74-L111)

**用途：** 通过每次合并两段最短木材，最小化总合并代价。

#### 算法概览

```

```

#### 堆操作

| 操作 | 函数 | 实现位置 | 复杂度 |
| --- | --- | --- | --- |
| 插入 | `HeapPush(heap, size, value)` | [p7/p7.cpp L56-L60](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L56-L60) | O(log N) |
| 取出最小值 | `HeapPop(heap, size)` | [p7/p7.cpp L62-L71](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L62-L71) | O(log N) |
| 上滤 | `SiftUp(heap, index)` | [p7/p7.cpp L11-L25](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L11-L25) | O(log N) |
| 下滤 | `SiftDown(heap, size, index)` | [p7/p7.cpp L27-L54](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L27-L54) | O(log N) |

#### 实现细节

* **堆结构：** 1 基下标数组（[p7/p7.cpp L86](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L86-L86)）
* **父节点下标：** `parent = index / 2`（[p7/p7.cpp L15](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L15-L15)）
* **子节点下标：** `left = index * 2`，`right = left + 1`（[p7/p7.cpp L31-L32](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L31-L32)）
* **合并策略：** 始终取两个最小元素（[p7/p7.cpp L100-L101](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L100-L101)）
* **代价累计：** 每次合并代价为两段长度之和（[p7/p7.cpp L103-L104](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L103-L104)）

#### 正确性（贪心选择性质）

该算法是最优的原因如下：

1. 每次合并会生成一段新木材，后续仍会参与合并
2. 始终选择两段最短木材，可最小化每段木材对总成本的累计贡献次数
3. 该过程等价于构造一棵哈夫曼树，其中叶子权值为木材长度

#### 复杂度分析

* **时间复杂度：** O(N log N) * 初始入堆：N × O(log N) = O(N log N)（[p7/p7.cpp L89-L94](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L89-L94)） * 主循环：(N-1) 次（[p7/p7.cpp L98](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L98-L98)） * 每次循环：2 次 HeapPop + 1 次 HeapPush = O(log N) * 总计：O(N log N)
* **空间复杂度：** O(N)（堆数组）

**来源：** [p7/p7.cpp L1-L111](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L1-L111)

---

## 排序算法

### 总览表

| 算法 | 函数 | 时间复杂度 | 空间复杂度 | 稳定 | 原地 |
| --- | --- | --- | --- | --- | --- |
| 冒泡排序 | `BubbleSort()` | O(N²) 最好/平均/最坏 | O(1) | 是 | 是 |
| 选择排序 | `SelectionSort()` | O(N²) 最好/平均/最坏 | O(1) | 否 | 是 |
| 插入排序 | `InsertionSort()` | O(N²) 平均/最坏，O(N) 最好 | O(1) | 是 | 是 |
| 希尔排序 | `ShellSort()` | O(N log² N)（常见） | O(1) | 否 | 是 |
| 快速排序 | `QuickSort()` | O(N log N) 平均，O(N²) 最坏 | O(log N) 递归栈 | 否 | 是 |
| 堆排序 | `HeapSort()` | O(N log N) 最好/平均/最坏 | O(1) | 否 | 是 |
| 归并排序 | `MergeSort()` | O(N log N) 最好/平均/最坏 | O(N) | 是 | 否 |
| 基数排序 | `RadixSort()` | O(d × N)，d 为位数 | O(N) | 是 | 否 |

**来源：** [p10/10_sorting_comparison.cpp L76-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L76-L371)

---

### 简单的 O(N²) 排序算法

#### 冒泡排序

**函数：** `BubbleSort(int *arr, int n, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L78-L98](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L78-L98)

```

```

**关键特性：**

* **优化：** 若一趟扫描无交换则提前结束（[p10/10_sorting_comparison.cpp L93-L96](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L93-L96)）
* **统计：** 在比较与交换处递增 `compare_count` 与 `swap_count`（[p10/10_sorting_comparison.cpp L85-L89](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L85-L89)）
* **最好情况：** O(N)，数组已排序（单趟且无交换）
* **最坏情况：** O(N²)，数组逆序

#### 选择排序

**函数：** `SelectionSort(int *arr, int n, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L100-L119](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L100-L119)

**算法：** 对于每个位置 i，在 `arr[i..n-1]` 中找到最小元素并交换到位置 i。

**实现细节：**

* 查找最小值下标（[p10/10_sorting_comparison.cpp L104-L112](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L104-L112)）
* 每轮外层循环只进行一次交换（[p10/10_sorting_comparison.cpp L113-L117](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L113-L117)）
* 总是执行 (N-1) + (N-2) + ... + 1 = N(N-1)/2 次比较
* **不稳定：** 可能将相等元素交换到不同相对顺序

#### 插入排序

**函数：** `InsertionSort(int *arr, int n, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L121-L143](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L121-L143)

**算法：** 逐个取元素插入到已排序区间的正确位置，从而不断扩展有序部分。

**关键特性：**

* **最好情况：** 对“几乎有序”的数据可达到 O(N)（[p10/10_sorting_comparison.cpp L128-L139](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L128-L139)）
* **在线：** 可在数据到达时持续插入排序
* **稳定：** 保持相等元素的相对顺序
* **自适应：** 输入越接近有序性能越好

**来源：** [p10/10_sorting_comparison.cpp L78-L143](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L78-L143)

---

### 高级 O(N log N) 排序算法

#### 希尔排序

**函数：** `ShellSort(int *arr, int n, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L145-L170](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L145-L170)

**增量序列：** `gap = n/2, gap /= 2, ..., gap = 1`（[p10/10_sorting_comparison.cpp L147](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L147-L147)

）

```

```

**相对插入排序的改进：**

* 允许交换相距较远的元素
* 降低最后一趟插入时的移动次数
* 增量序列会影响性能；当前实现采用 n/2 递减序列

#### 快速排序

**函数：** `QuickSort(int *arr, int n, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L207-L213](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L207-L213)

**划分函数：** `Partition(int *arr, int low, int high, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L172-L195](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L172-L195)

**划分策略：**

* **枢轴选择：** 取最后一个元素 `arr[high]`（[p10/10_sorting_comparison.cpp L174](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L174-L174)）
* **不变式：** ≤ 枢轴的元素在左侧，> 枢轴的元素在右侧
* **实现：** 双指针扫描（[p10/10_sorting_comparison.cpp L175-L188](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L175-L188)）

**递归模式：**

```

```

**复杂度要点：**

* **平均：** 分区较均衡时为 O(N log N)
* **最坏：** 枢轴总为最小/最大时退化为 O(N²)（例如已排序数组）
* **空间：** 平均递归深度 O(log N)，最坏 O(N)

#### 堆排序

**函数：** `HeapSort(int *arr, int n, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L251-L263](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L251-L263)

**堆化函数：** `Heapify(int *arr, int n, int i, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L215-L249](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L215-L249)

**两阶段过程：**

1. **构建大根堆**（[p10/10_sorting_comparison.cpp L253-L256](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L253-L256)） * 从最后一个非叶子结点开始：`i = n/2 - 1` * 自底向上对每个结点调用 `Heapify()`
2. **依次取出元素**（[p10/10_sorting_comparison.cpp L257-L262](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L257-L262)） * 交换堆顶（最大）与末尾元素 * 缩小堆规模 * 对堆顶重新 `Heapify` 以恢复大根堆性质

**堆化实现：**

* **0 基下标堆：** 左孩子 = `2*i + 1`，右孩子 = `2*i + 2`（[p10/10_sorting_comparison.cpp L220-L221](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L220-L221)）
* **迭代下滤：** 与孩子比较，和更大的那个交换（[p10/10_sorting_comparison.cpp L217-L248](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L217-L248)）
* **单次堆化时间：** O(log N)

**特性：**

* **始终 O(N log N)：** 不会出现最坏情况退化
* **原地：** 额外空间 O(1)
* **不稳定：** 堆操作可能交换相等元素

#### 归并排序

**函数：** `MergeSort(int *arr, int n, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L312-L321](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L312-L321)

**合并函数：** `Merge(int *arr, int *tmp, int left, int mid, int right, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L265-L298](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L265-L298)

```

```

**合并算法细节：**

* **双指针：** 同时扫描左右两段（[p10/10_sorting_comparison.cpp L267-L282](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L267-L282)）
* **拷贝剩余元素：** 处理两段长度不等的情况（[p10/10_sorting_comparison.cpp L284-L293](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L284-L293)）
* **临时数组：** 合并过程需要额外缓存（[p10/10_sorting_comparison.cpp L318](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L318-L318)）
* **统计：** 每次元素移动按交换计数（[p10/10_sorting_comparison.cpp L282-L292](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L282-L292)）

**稳定性：** 当 `arr[i] <= arr[j]` 时保持相对顺序（[p10/10_sorting_comparison.cpp L274](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L274-L274)

）

**来源：** [p10/10_sorting_comparison.cpp L145-L321](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L145-L321)

---

### 非比较类排序

#### 基数排序

**函数：** `RadixSort(int *arr, int n, SortStatistics &stats)`
**位置：** [p10/10_sorting_comparison.cpp L323-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L323-L371)

**算法：** 基于 10 进制的 LSD（最低位优先）基数排序。

```

```

**实现步骤：**

1. **找到最大值**（[p10/10_sorting_comparison.cpp L330-L337](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L330-L337)）：决定需要进行多少趟按位分配
2. **取位：** `digit = (arr[i] / exp) % 10`（[p10/10_sorting_comparison.cpp L350-L359](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L350-L359)）
3. **逐位计数排序：** * 统计出现次数（[p10/10_sorting_comparison.cpp L348-L352](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L348-L352)） * 计算位置（[p10/10_sorting_comparison.cpp L353-L356](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L353-L356)） * 放置元素（[p10/10_sorting_comparison.cpp L357-L363](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L357-L363)）
4. **拷回原数组**（[p10/10_sorting_comparison.cpp L364-L367](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L364-L367)）

**关键性质：**

* **非比较排序：** O(d × N)，d 为位数
* **稳定：** 在每一趟按位排序中保持相对顺序
* **与范围有关：** 性能取决于最大值范围，而不只是 N
* **空间：** 输出数组 O(N) + 计数数组 O(10)

**按交换计数：** 统计系统将每次元素放置计为一次交换（[p10/10_sorting_comparison.cpp L362](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L362-L362)

）

**来源：** [p10/10_sorting_comparison.cpp L323-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L323-L371)

---

## 性能测量系统

### 统计信息采集

**结构体：** `SortStatistics`
**位置：** [p10/10_sorting_comparison.cpp L12-L26](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L12-L26)

```

```

### 度量实现

| 指标 | 统计方式 | 位置 |
| --- | --- | --- |
| 比较次数 | 在比较操作处 `stats.compare_count++` | 各算法多处位置 |
| 交换/移动次数 | 在交换/移动操作处 `stats.swap_count++` | 各算法多处位置 |
| 时间 | 排序执行前后调用 `clock()` | [p10/10_sorting_comparison.cpp L394-L398](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L394-L398) |
| 转换 | `(end - start) * 1000.0 / kClocksPerSec` | [p10/10_sorting_comparison.cpp L398](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L398-L398) |

### 测试规模

**标准规模：** [p10/10_sorting_comparison.cpp L568-L571](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L568-L571)

* 100 个元素
* 1,000 个元素
* 10,000 个元素
* 100,000 个元素

**随机数生成：** [p10/10_sorting_comparison.cpp L51-L74](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L51-L74)

* 线性同余发生器（LCG）
* 种子：`123456789u`（[p10/10_sorting_comparison.cpp L65](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L65-L65)）
* 公式：`seed = seed * 1103515245u + 12345u`（[p10/10_sorting_comparison.cpp L53](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L53-L53)）
* 取值范围：0 到 999,999（[p10/10_sorting_comparison.cpp L71](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L71-L71)）

**来源：** [p10/10_sorting_comparison.cpp L1-L581](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L1-L581)

---

## 算法复杂度汇总

### 复杂度对照矩阵

| 算法 | 最好时间 | 平均时间 | 最坏时间 | 空间 | 位置 |
| --- | --- | --- | --- | --- | --- |
| **图算法** |  |  |  |  |  |
| DFS | O(V+E) | O(V+E) | O(V+E) | O(V) | [p3/maze_game.cpp L113-L150](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp#L113-L150) |
| Prim 最小生成树 | O(V²) | O(V²) | O(V²) | O(V²) | [p8/p8.cpp L227-L311](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L227-L311) |
| **贪心算法** |  |  |  |  |  |
| 哈夫曼合并 | O(N log N) | O(N log N) | O(N log N) | O(N) | [p7/p7.cpp L74-L111](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L74-L111) |
| **简单排序** |  |  |  |  |  |
| 冒泡排序 | O(N) | O(N²) | O(N²) | O(1) | [p10/10_sorting_comparison.cpp L78-L98](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L78-L98) |
| 选择排序 | O(N²) | O(N²) | O(N²) | O(1) | [p10/10_sorting_comparison.cpp L100-L119](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L100-L119) |
| 插入排序 | O(N) | O(N²) | O(N²) | O(1) | [p10/10_sorting_comparison.cpp L121-L143](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L121-L143) |
| **高级排序** |  |  |  |  |  |
| 希尔排序 | O(N log N) | O(N log² N) | O(N log² N) | O(1) | [p10/10_sorting_comparison.cpp L145-L170](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L145-L170) |
| 快速排序 | O(N log N) | O(N log N) | O(N²) | O(log N) | [p10/10_sorting_comparison.cpp L207-L213](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L207-L213) |
| 堆排序 | O(N log N) | O(N log N) | O(N log N) | O(1) | [p10/10_sorting_comparison.cpp L251-L263](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L251-L263) |
| 归并排序 | O(N log N) | O(N log N) | O(N log N) | O(N) | [p10/10_sorting_comparison.cpp L312-L321](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L312-L321) |
| **非比较** |  |  |  |  |  |
| 基数排序 | O(d×N) | O(d×N) | O(d×N) | O(N+k) | [p10/10_sorting_comparison.cpp L323-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L323-L371) |

### 算法选择指南

```

```

**来源：** 本仓库全部算法实现，分布在 [p3/maze_game.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p3/maze_game.cpp)

 [p7/p7.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp)

 [p8/p8.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp)

 [p10/10_sorting_comparison.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp)

---

## 代码组织模式

### 算法与统计的集成方式

本项目中的所有排序算法都遵循统一的接口模式：

```

```

**所有排序的一致模式：**

1. 函数签名：`void FunctionName(int *arr, int n, SortStatistics &stats)`
2. 在每次比较之前/之后递增 `stats.compare_count`
3. 对每一次元素移动递增 `stats.swap_count`
4. 算法逻辑直接操作 `arr`（或使用辅助空间）

**函数指针数组：** [p10/10_sorting_comparison.cpp L425-L433](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L425-L433)

```

```

### 堆实现模式对比（p7 vs p10）

两个项目都使用了堆结构，但采用了不同的下标约定：

| 方面 | p7（小根堆） | p10（HeapSort 中的大根堆） |
| --- | --- | --- |
| **下标基准** | 1 基数组 | 0 基数组 |
| **父节点公式** | `index / 2` | `(index - 1) / 2`（隐含） |
| **左孩子** | `index * 2` | `2 * index + 1` |
| **右孩子** | `index * 2 + 1` | `2 * index + 2` |
| **根下标** | 1 | 0 |
| **比较方式** | `<`（小根堆） | `>`（大根堆） |

**来源：** [p7/p7.cpp L11-L71](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L11-L71)

 [p10/10_sorting_comparison.cpp L215-L263](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L215-L263)

---

## 相关页面

* 关于哈希表算法与队列操作，请参见 [Data Structures Reference](数据结构参考.md)
* 关于项目级用法示例与 I/O 模式，请参见 [Projects Overview](项目概览.md)
* 关于性能基准测试的方法，请参见 [Project 10: Sorting Algorithm Comparison](项目十-排序算法比较.md)
* 关于单个算法的应用：* DFS：[Project 3: Maze Game](项目三-勇闯迷宫游戏.md) * Prim 最小生成树：[Project 8: Power Grid Cost Simulation](项目八-电网建设造价模拟.md) * 哈夫曼式合并：[Project 7: Repair Ranch](项目七-修理牧场（最小花费）.md) * 全部排序算法：[Project 10: Sorting Algorithm Comparison](项目十-排序算法比较.md)
