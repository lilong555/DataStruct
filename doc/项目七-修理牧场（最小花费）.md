# 项目七：修理牧场（最小花费）

本项目解决“锯木头最小花费/最优合并”问题：将 N 段木头合并为一段的过程中，每次合并的代价等于两段长度之和，目标是使总代价最小。

## 贪心策略

每一步都选择当前 **最短的两段** 进行合并，这是最优的（与哈夫曼树构造一致）。

算法流程：

1. 将所有长度放入小根堆
2. 重复执行直到堆中只剩 1 个元素：
   - 取出最小的两段 `a`、`b`
   - 合并代价 `a+b` 加入总花费
   - 将新段 `a+b` 放回堆中

## 为什么是最优的（直观解释）

若把合并过程看作一棵二叉树，叶子为原始木段长度，总代价等价于“带权路径长度”。最短的两段尽早合并可以让较小的权重处在更深层，从而减少总贡献。

## 复杂度

- 时间复杂度：O(N log N)
- 空间复杂度：O(N)

## 编译与运行

```bash
g++ -std=c++17 -O2 -Wall -Wextra -pedantic p7/p7.cpp -o output/p7
./output/p7
```

