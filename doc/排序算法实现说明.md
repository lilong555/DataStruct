# 排序算法实现说明

> **相关源文件**
> * [p10/10_sorting_comparison.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp)

## 目的与范围

本页说明项目十比较系统中的 8 种排序算法实现。每种算法均以独立函数实现，对整型数组进行排序，并在排序过程中采集性能统计信息。实现位于 [p10/10_sorting_comparison.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp)，包含简单的 O(N²) 算法（冒泡、选择、插入）、较高级的比较类算法（希尔、快速、堆、归并）以及一种非比较算法（基数排序）。

如需了解性能测量与统计采集框架，请参见 [Performance Metrics System](性能统计系统.md)。如需了解项目十整体结构与菜单交互，请参见 [Project 10: Sorting Algorithm Comparison](项目十-排序算法比较.md)。

**来源：** [p10/10_sorting_comparison.cpp L1-L581](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L1-L581)

---

## 算法概览与特性

本项目中的所有排序算法均遵循统一的函数签名：

```
void SortAlgorithm(int *arr, int n, SortStatistics &stats)
```

其中 `arr` 为待排序数组，`n` 为数组长度，`stats` 为 `SortStatistics` 引用，用于记录 `compare_count`、`swap_count` 与 `time_elapsed_ms`。

### 算法对比表

| 算法 | 函数名 | 时间复杂度（最好/平均/最坏） | 空间复杂度 | 原地 | 稳定 | 行号范围 |
| --- | --- | --- | --- | --- | --- | --- |
| 冒泡排序 | `BubbleSort` | O(N) / O(N²) / O(N²) | O(1) | 是 | 是 | [78-98](https://github.com/lilong555/DataStruct/blob/660fbbaa/78-98) |
| 选择排序 | `SelectionSort` | O(N²) / O(N²) / O(N²) | O(1) | 是 | 否 | [100-119](https://github.com/lilong555/DataStruct/blob/660fbbaa/100-119) |
| 插入排序 | `InsertionSort` | O(N) / O(N²) / O(N²) | O(1) | 是 | 是 | [121-143](https://github.com/lilong555/DataStruct/blob/660fbbaa/121-143) |
| 希尔排序 | `ShellSort` | O(N log N) / O(N^1.3) / O(N²) | O(1) | 是 | 否 | [145-170](https://github.com/lilong555/DataStruct/blob/660fbbaa/145-170) |
| 快速排序 | `QuickSort` | O(N log N) / O(N log N) / O(N²) | O(log N) | 是 | 否 | [207-213](https://github.com/lilong555/DataStruct/blob/660fbbaa/207-213) |
| 堆排序 | `HeapSort` | O(N log N) / O(N log N) / O(N log N) | O(1) | 是 | 否 | [251-263](https://github.com/lilong555/DataStruct/blob/660fbbaa/251-263) |
| 归并排序 | `MergeSort` | O(N log N) / O(N log N) / O(N log N) | O(N) | 否 | 是 | [312-321](https://github.com/lilong555/DataStruct/blob/660fbbaa/312-321) |
| 基数排序 | `RadixSort` | O(d·N) / O(d·N) / O(d·N) | O(N+k) | 否 | 是 | [323-371](https://github.com/lilong555/DataStruct/blob/660fbbaa/323-371) |

**来源：** [p10/10_sorting_comparison.cpp L78-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L78-L371)

---

## 算法注册与分发系统

```

```

系统采用“函数指针注册表”模式：`AlgorithmEntry` 结构体将中文算法名与对应函数指针配对。`SortFunc` 类型别名见 [p10/10_sorting_comparison.cpp L375](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L375-L375)，其签名为 `void (*)(int *, int, SortStatistics &)`。因此 `ExecuteSort()` 与 `TestSingleAlgorithm()` 都可以用统一方式调用任意算法。

**来源：** [p10/10_sorting_comparison.cpp L375-L381](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L375-L381)

 [p10/10_sorting_comparison.cpp L425-L433](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L425-L433)

 [p10/10_sorting_comparison.cpp L482-L490](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L482-L490)

---

## 简单 O(N²) 算法

### 冒泡排序

**函数：** `BubbleSort`（[p10/10_sorting_comparison.cpp L78-L98](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L78-L98)）

冒泡排序进行相邻元素比较，并带有“提前结束”的优化：使用 `swapped` 标志判断某一趟扫描是否发生交换；若未交换则说明数组已排序。

```

```

**关键实现细节：**

* **第 82 行：** 每一趟开始将 `swapped = false`
* **第 85 行：** 每次比较前递增比较计数
* **第 88 行：** 使用辅助函数 `SwapInt()`（定义见 [p10/10_sorting_comparison.cpp L44-L49](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L44-L49)）
* **第 93-96 行：** 若整趟无交换则提前结束

**来源：** [p10/10_sorting_comparison.cpp L78-L98](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L78-L98)

 [p10/10_sorting_comparison.cpp L44-L49](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L44-L49)

---

### 选择排序

**函数：** `SelectionSort`（[p10/10_sorting_comparison.cpp L100-L119](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L100-L119)）

选择排序在未排序区间中寻找最小元素，并将其放到已排序区间的末尾。与冒泡排序不同，它在每轮外层循环最多进行一次交换（若需要）。

**算法结构：**

```
for i = 0 to n-2:
    min_idx = i
    for j = i+1 to n-1:
        stats.compare_count++
        if arr[j] < arr[min_idx]:
            min_idx = j
    if min_idx != i:
        swap(arr[i], arr[min_idx])
        stats.swap_count++
```

**关键实现细节：**

* **第 104 行：** 将 `min_idx` 初始化为当前位置
* **第 107 行：** 在寻找最小值时统计比较次数
* **第 113-116 行：** 仅当最小值不在当前位置时才交换（降低交换次数）
* **交换次数上限：** 不论输入分布如何，最多 N-1 次交换

**来源：** [p10/10_sorting_comparison.cpp L100-L119](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L100-L119)

---

### 插入排序

**函数：** `InsertionSort`（[p10/10_sorting_comparison.cpp L121-L143](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L121-L143)）

插入排序通过不断把新元素插入到已排序前缀中，逐步扩大有序区间。实现中使用 while 循环不断右移元素，直到找到插入位置。

```

```

**关键实现细节：**

* **第 125 行：** 将当前元素保存为待插入的 `key`
* **第 129 行：** 即使跳出循环也会对比较次数进行计数
* **第 132 行：** 每次右移视作一次“交换”（用于统计）
* **第 141 行：** 将 `key` 放到最终位置 `j+1`
* **最好情况：** 数组已排序时为 O(N)（仅 N-1 次比较）

**来源：** [p10/10_sorting_comparison.cpp L121-L143](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L121-L143)

---

## 高级 O(N log N) 算法

### 希尔排序

**函数：** `ShellSort`（[p10/10_sorting_comparison.cpp L145-L170](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L145-L170)）

希尔排序是插入排序的推广：允许交换相距较远的元素。该实现使用增量序列从 N/2 开始并不断除以 2。

**增量序列与算法：**

```yaml
for gap = n/2; gap > 0; gap /= 2:
    for i = gap to n-1:
        temp = arr[i]
        j = i
        while j >= gap:
            stats.compare_count++
            if arr[j-gap] > temp:
                arr[j] = arr[j-gap]
                stats.swap_count++
                j -= gap
            else:
                break
        arr[j] = temp
```

**关键实现细节：**

* **第 147 行：** 增量序列 N/2、N/4、N/8、...、1（Shell 原始序列）
* **第 149-168 行：** 在 gap 间隔上执行“插入排序”式的内部循环
* **第 155 行：** 在 gap 插入过程中统计比较次数
* **第 158-159 行：** 以 `gap` 为步长移动元素
* **时间复杂度：** 与增量序列相关；该实现平均约为 O(N^1.3) 到 O(N^1.5)

**来源：** [p10/10_sorting_comparison.cpp L145-L170](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L145-L170)

---

### 快速排序

**函数集合：**

* `QuickSort` 入口（[p10/10_sorting_comparison.cpp L207-L213](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L207-L213)）
* `QuickSortRecursive`（[p10/10_sorting_comparison.cpp L197-L205](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L197-L205)）
* `Partition`（[p10/10_sorting_comparison.cpp L172-L195](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L172-L195)）

快速排序采用分治策略并进行原地分区。该实现选择最后一个元素作为枢轴（pivot）。

```

```

**关键实现细节：**

* **第 174 行：** 固定选择最后一个元素（`arr[high]`）作为 pivot
* **第 175 行：** 下标 `i` 记录“最后一个小元素”的位置
* **第 182-185 行：** 仅在元素不同时交换，避免无效操作
* **第 189-192 行：** 最终交换将 pivot 放到正确位置
* **第 201-203 行：** 递归处理左右子数组
* **最坏情况：** 数组已排序时容易出现不均衡分区，退化为 O(N²)

**来源：** [p10/10_sorting_comparison.cpp L172-L213](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L172-L213)

---

### 堆排序

**函数集合：**

* `HeapSort`（[p10/10_sorting_comparison.cpp L251-L263](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L251-L263)）
* `Heapify`（[p10/10_sorting_comparison.cpp L215-L249](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L215-L249)）

堆排序先构建大根堆，然后反复取出最大值。`Heapify` 采用迭代式实现，而不是递归。

```

```

**关键实现细节：**

* **第 253-255 行：** 自底向上建堆，从最后一个非叶子结点开始
* **第 217-248 行：** while 循环实现迭代 heapify，避免递归
* **第 220-221 行：** 0 基堆：左孩子 2i+1，右孩子 2i+2
* **第 225-236 行：** 与两个孩子比较并统计每次比较
* **第 240-242 行：** 当前结点满足堆性质时终止
* **保证 O(N log N)：** 与快速排序不同，不存在平方级最坏退化

**来源：** [p10/10_sorting_comparison.cpp L215-L263](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L215-L263)

---

### 归并排序

**函数集合：**

* `MergeSort` 入口（[p10/10_sorting_comparison.cpp L312-L321](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L312-L321)）
* `MergeSortRecursive`（[p10/10_sorting_comparison.cpp L300-L310](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L300-L310)）
* `Merge`（[p10/10_sorting_comparison.cpp L265-L298](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L265-L298)）

归并排序是经典分治算法，合并时使用额外临时数组。

```

```

**关键实现细节：**

* **第 318 行：** 在顶层一次性分配 O(N) 临时数组
* **第 306 行：** 谨慎计算 mid，避免整数溢出
* **第 273 行：** 合并过程中的每次比较都会计数
* **第 282 行：** 拷贝到临时数组的每个元素移动计为一次“交换”
* **第 287、292 行：** 拷贝剩余元素时递增交换计数
* **第 294-297 行：** 最终从临时数组拷回原数组
* **稳定性：** 第 274 行使用 ≤ 而不是 &lt;，保持相等元素相对顺序
* **空间复杂度：** 临时数组需要 O(N)

**来源：** [p10/10_sorting_comparison.cpp L265-L321](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L265-L321)

---

## 非比较算法

### 基数排序

**函数：** `RadixSort`（[p10/10_sorting_comparison.cpp L323-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L323-L371)）

基数排序是本集合中唯一的非比较算法。它按位处理整数，并以计数排序作为稳定子过程。

```

```

**关键实现细节：**

* **第 330-337 行：** 找最大值以确定位数（d）
* **第 342 行：** 从最低位（exp=1）到最高位依次处理
* **第 350 行：** 取当前位：`(arr[i] / exp) % 10`
* **第 353-356 行：** 前缀和将计数转为位置
* **第 357-363 行：** 从右到左放置，保持稳定性
* **第 362 行：** 每次放置计为一次交换（用于统计）
* **时间复杂度：** O(d·N)，d 为位数（log₁₀(max_val)）
* **非比较排序：** 不直接比较数组元素
* **稳定性：** 第 357 行的从右到左放置保持相对顺序

**为何不统计比较次数：** 基数排序不会比较数组元素，因此 `stats.compare_count` 保持为 0。

**来源：** [p10/10_sorting_comparison.cpp L323-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L323-L371)

---

## 共同实现模式

### 统计系统的集成方式

所有排序函数在性能统计集成方面遵循一致模式：

```

```

**模式规则：**

1. **比较计数：** 每次比较操作前递增（例如 BubbleSort 第 85 行，SelectionSort 第 107 行）
2. **交换计数：** 每次交换/移动后递增（例如 BubbleSort 第 89 行，SelectionSort 第 116 行）
3. **归并/基数特殊情况：** 元素移动按交换计数（Merge 第 282 行，RadixSort 第 362 行）
4. **计时：** 由 `ExecuteSort()` 统一在外部处理（[p10/10_sorting_comparison.cpp L394-L398](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L394-L398)）

**来源：** [p10/10_sorting_comparison.cpp L78-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L78-L371)

 [p10/10_sorting_comparison.cpp L394-L398](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L394-L398)

---

### 交换工具函数

所有算法共用一个交换辅助函数：

**函数：** `SwapInt`（[p10/10_sorting_comparison.cpp L44-L49](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L44-L49)）

```
static void SwapInt(int &a, int &b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

该函数使用临时变量完成三步交换，被以下实现调用：

* BubbleSort（第 88 行）
* SelectionSort（第 115 行）
* QuickSort 的 Partition（第 184、191 行）
* HeapSort 的 Heapify（第 245 行）

**来源：** [p10/10_sorting_comparison.cpp L44-L49](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L44-L49)

---

### 随机数据生成

**函数：** `GenerateRandomArray`（[p10/10_sorting_comparison.cpp L57-L74](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L57-L74)）

所有算法都在同一份随机数据上测试，该随机数据由自定义线性同余发生器（LCG）生成：

```
seed = seed * 1103515245u + 12345u
random_value = (seed / 65536u) % 32768u
```

**关键实现细节：**

* **第 51-55 行：** `NextRand()` 实现标准 LCG（常用常数）
* **第 65 行：** 固定种子 `123456789u` 确保结果可复现
* **第 68-71 行：** 两次随机调用组合以扩大取值范围
* **第 71 行：** 最终对 1000000 取模（取值范围 [0, 999999]）
* **可复现性：** 相同种子生成相同序列，保证公平对比

**来源：** [p10/10_sorting_comparison.cpp L51-L74](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L51-L74)

---

## 算法复杂度汇总

```

```

**按使用场景的性能建议：**

| 使用场景 | 推荐算法 | 原因 |
| --- | --- | --- |
| 小数组（N &lt; 50） | InsertionSort、SelectionSort | 固定开销小，实现简单 |
| 近乎有序 | BubbleSort（提前结束）、InsertionSort | 最好情况可达 O(N) |
| 保证 O(N log N) | HeapSort、MergeSort | 不存在平方级最坏退化 |
| 空间受限 | BubbleSort、SelectionSort、HeapSort | 辅助空间 O(1) |
| 需要稳定性 | BubbleSort、InsertionSort、MergeSort、RadixSort | 保持相等元素相对顺序 |
| 仅整型数据 | RadixSort | 非比较，d 小时接近线性 |
| 通用 | QuickSort、MergeSort | 平均性能良好 |

**来源：** [p10/10_sorting_comparison.cpp L78-L371](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L78-L371)

---

## 实现约束

本项目按课程要求存在特定教学约束：

**头文件限制：** 只允许使用三个标准库头文件：

* `<iostream>` 用于控制台 I/O（[p10/10_sorting_comparison.cpp L1](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L1-L1)）
* `<cmath>` 用于数学运算（[p10/10_sorting_comparison.cpp L2](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L2-L2)）
* `<cstring>` 用于字符串操作（[p10/10_sorting_comparison.cpp L3](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L3-L3)）

**影响：**

* 不能使用 STL 容器（`<vector>`、`<array>` 等）
* 不能使用 STL 算法（`<algorithm>`）
* 不能使用 `<string>`（必须使用 C 风格字符串）
* 需要使用 `new`/`delete` 手动管理内存
* 需要自行实现所需数据结构

这些约束促使学生从第一原则实现算法，而不依赖标准库设施。

**来源：** [p10/10_sorting_comparison.cpp L1-L3](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp#L1-L3)
