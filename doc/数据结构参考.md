# 数据结构参考

> **相关源文件**
> * [CLAUDE.md](https://github.com/lilong555/DataStruct/blob/660fbbaa/CLAUDE.md)
> * [p1/p1.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp)
> * [p5/bank_service.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp)
> * [p5/bank_service.exe](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.exe)
> * [p7/p7.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp)
> * [p8/p8.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp)

## 目的与范围

本文档对 DataStruct 仓库中实现的数据结构进行跨项目的综合参考整理，汇总各结构的具体实现方式、复杂度特性与在项目中的使用模式，覆盖项目 1、3、5、7、8 与 10。

如需查看使用这些结构实现的算法（DFS、Prim 最小生成树、各类排序算法），请参见 [Algorithms Reference](算法参考.md)。如需项目级说明，请参见各项目页面（[Project 1](项目一-考试报名系统.md)、[Project 5](项目五-银行业务模拟.md)、[Project 7](项目七-修理牧场（最小花费）.md)、[Project 8](项目八-电网建设造价模拟.md)、[Project 10](项目十-排序算法比较.md)）。

---

## 数据结构实现映射

```

```

**来源：** [p1/p1.cpp L15-L55](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L15-L55)

 [p5/bank_service.cpp L7-L35](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L7-L35)

 [p7/p7.cpp L86](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L86-L86)

 [p8/p8.cpp L5-L45](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L5-L45)

 [p10/10_sorting_comparison.cpp](https://github.com/lilong555/DataStruct/blob/660fbbaa/p10/10_sorting_comparison.cpp)

---

## 拉链法哈希表（Separate Chaining）

### 实现：ExamRegistrationSystem

项目一使用经典的“拉链法（separate chaining）”来解决哈希冲突。

```

```

**关键实现细节：**

| 常量 | 值 | 用途 | 位置 |
| --- | --- | --- | --- |
| `HASH_TABLE_SIZE` | 997 | 取质数以提升分布均匀性 | [p1/p1.cpp L16](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L16-L16) |
| `A` | 2654435769 | 乘法散列常数（(φ-1) × 2³²） | [p1/p1.cpp L125](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L125-L125) |

### 哈希函数分析

哈希函数位于 [p1/p1.cpp L122-L128](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L122-L128)，实现了乘法散列（multiplicative hashing）：

```
hash = (2654435769 * exam_id) >> 16
index = hash % 997
```

该方法的特点：

* 使用黄金分割共轭常数以获得更均匀的分布
* 右移 16 位以使用高位信息
* 对 997（质数）取模以降低聚簇（clustering）

### 核心操作

| 操作 | 方法 | 复杂度 | 位置 |
| --- | --- | --- | --- |
| 插入 | `Insert()` | 平均 O(1)，最坏 O(n) | [p1/p1.cpp L421-L442](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L421-L442) |
| 删除 | `DeleteByExamId()` | 平均 O(1)，最坏 O(n) | [p1/p1.cpp L459-L492](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L459-L492) |
| 查找 | `FindByExamId()` | 平均 O(1)，最坏 O(n) | [p1/p1.cpp L444-L457](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L444-L457) |
| 遍历 | `PrintAll()` | O(n + m)，m=997 | [p1/p1.cpp L212-L234](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L212-L234) |

### 结点结构

[p1/p1.cpp L19-L25](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L19-L25) 定义了链表结点：

```

```

**来源：** [p1/p1.cpp L15-L457](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L15-L457)

---

## 数组队列（Array-Based Queues）

### 实现：Bank Service Simulation

项目五实现了两个相互独立的数组队列，并通过手动下标推进的方式出队，而不是使用循环队列（circular buffer）的写法。

```

```

### 队列特性

| 队列 | 分配规则 | 服务时间 | 数组 | 长度计数 |
| --- | --- | --- | --- | --- |
| A | `id % 2 == 1` | 1 单位时间 | `queue_a[]` | `size_a` |
| B | `id % 2 == 0` | 2 单位时间 | `queue_b[]` | `size_b` |

### 数据结构

**常量：** [p5/bank_service.cpp L7](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L7-L7)

```

```

**客户结构体：** [p5/bank_service.cpp L10-L15](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L10-L15)

```

```

### 队列操作

该实现使用简单的数组下标推进，不引入循环队列机制：

| 操作 | 实现方式 | 复杂度 | 位置 |
| --- | --- | --- | --- |
| 入队 | 数组赋值 `queue[size++]` | O(1) | [p5/bank_service.cpp L29-L33](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L29-L33) |
| 出队 | 下标自增 `index++` | O(1) | [p5/bank_service.cpp L72-L119](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L72-L119) |
| 判空 | `index < size` | O(1) | [p5/bank_service.cpp L49-L112](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L49-L112) |

### 仿真逻辑

`SimulateBankService()` 位于 [p5/bank_service.cpp L39-L124](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L39-L124)，实现了离散时间的“优先输出”调度逻辑：

1. 跟踪当前处理位置（`index_a`、`index_b`）
2. 维护剩余服务时间（`time_a`、`time_b`）
3. 在每一步比较两窗口的完成时间
4. 当某窗口完成服务时输出客户 ID
5. 处理优先级：当两窗口同时完成时，先输出队列 A（[p5/bank_service.cpp L87-L101](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L87-L101)）

**来源：** [p5/bank_service.cpp L7-L124](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L7-L124)

---

## 小根堆（Min-Heap / Binary Heap）

### 实现：基于数组的 1 基下标堆

项目七为了实现“哈夫曼式合并”，采用 1 基数组表示的小根堆。

```

```

### 堆性质

**下标关系**（1 基下标）：

* 结点 `i` 的父结点：`i / 2`
* 结点 `i` 的左孩子：`i * 2`
* 结点 `i` 的右孩子：`i * 2 + 1`

**小根堆不变式：** 对所有结点都满足 `heap[parent] ≤ heap[child]`

### 核心操作实现

#### SiftUp

[p7/p7.cpp L11-L25](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L11-L25) 在插入后向上恢复堆性质：

```

```

#### SiftDown

[p7/p7.cpp L27-L54](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L27-L54) 在取出元素后向下恢复堆性质：

```

```

### 操作复杂度

| 操作 | 函数 | 时间复杂度 | 位置 |
| --- | --- | --- | --- |
| 插入 | `HeapPush()` | O(log n) | [p7/p7.cpp L56-L60](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L56-L60) |
| 取出最小值 | `HeapPop()` | O(log n) | [p7/p7.cpp L62-L71](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L62-L71) |
| 查看最小值 | `heap[1]` | O(1) | [p7/p7.cpp L64](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L64-L64) |
| 建堆 | 依次插入 n 次 | O(n log n) | [p7/p7.cpp L89-L94](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L89-L94) |

### 应用：哈夫曼式合并

主算法位于 [p7/p7.cpp L98-L106](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L98-L106)，重复执行：

1. 取出两个最小元素（`HeapPop`）
2. 合并（求和）
3. 将合并结果再次插入（`HeapPush`）
4. 累加总成本

该过程实现 O(N log N) 的最优合并复杂度。

**来源：** [p7/p7.cpp L11-L111](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L11-L111)

---

## 图：邻接矩阵（Adjacency Matrix）

### 实现：PowerGridSystem

项目八使用二维邻接矩阵表示无向带权图，以支持 Prim 最小生成树算法。

```

```

### 数据结构定义

**常量：** [p8/p8.cpp L5-L8](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L5-L8)

```

```

**边结构体：** [p8/p8.cpp L11-L16](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L11-L16)

```

```

### 邻接矩阵性质

| 属性 | 取值 | 用途 |
| --- | --- | --- |
| 维度 | `kMaxNodes × kMaxNodes` | 支持最多 100 个顶点 |
| 对角线 | 0 | 自环代价为 0 |
| 无边 | `kInfinity` | 表示不存在边 |
| 对称性 | `adj_matrix_[i][j] = adj_matrix_[j][i]` | 无向图 |

### 矩阵初始化

[p8/p8.cpp L58-L64](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L58-L64) 初始化矩阵：

```

```

### 边操作

**添加边：** [p8/p8.cpp L169-L225](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L169-L225)

* 用户输入两个顶点名称与权值
* 通过 `GetVertexIndex()` 将名称转换为下标
* 校验顶点存在且不相同（禁止自环）
* 对称赋值：`adj_matrix_[u][v] = adj_matrix_[v][u] = weight`

**查询边：** 直接通过数组访问 `adj_matrix_[i][j]`

### Prim 算法的辅助数组

[p8/p8.cpp L247-L260](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L247-L260) 使用如下辅助数组：

| 数组 | 类型 | 用途 |
| --- | --- | --- |
| `lowcost[i]` | `int[kMaxNodes]` | 从 MST 到顶点 i 的最小连接边权 |
| `closest[i]` | `int[kMaxNodes]` | 与顶点 i 最近的 MST 内顶点 |
| `visited[i]` | `bool[kMaxNodes]` | 顶点 i 是否已加入 MST |

这些数组使 Prim 算法可以以 O(V²) 的方式执行。

### 空间复杂度

* 邻接矩阵：O(V²) = O(100²) = 10,000 个整数
* 顶点名称：O(V × L) = O(100 × 50) = 5,000 个字符
* MST 存储：O(V) = O(100) 条边
* 总计：O(V²)，由矩阵主导

**来源：** [p8/p8.cpp L5-L345](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L5-L345)

---

## 数组化数据结构

### 跨项目的定长数组

多个项目为获得可预测的内存管理，使用静态数组分配：

```

```

### 数组分配策略

| 项目 | 结构 | 大小 | 分配方式 | 用途 |
| --- | --- | --- | --- | --- |
| P1 | `table_` | 997 | 静态 | 哈希桶数组 |
| P5 | `customers` | 1000 | 静态 | 输入数据 |
| P5 | `queue_a/b` | 1000 | 静态 | 分流队列 |
| P7 | `heap` | 可变 | 动态 | 小根堆 |
| P8 | `adj_matrix_` | 100×100 | 静态 | 图边权 |
| P8 | `vertex_names_` | 100×50 | 静态 | 顶点标签 |
| P8 | `mst_edges_` | 100 | 静态 | MST 结果 |
| P10 | 测试数组 | 100-100K | 动态 | 排序输入 |

### 内存布局：PowerGridSystem 类

[p8/p8.cpp L39-L48](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L39-L48) 展示了成员数组的布局：

```

```

**来源：** [p1/p1.cpp L55](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L55-L55)

 [p5/bank_service.cpp L7-L142](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L7-L142)

 [p7/p7.cpp L86](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L86-L86)

 [p8/p8.cpp L39-L48](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L39-L48)

---

## 复杂度对照表

### 按数据结构划分的时间复杂度

| 数据结构 | 访问 | 查找 | 插入 | 删除 | 空间 |
| --- | --- | --- | --- | --- | --- |
| **哈希表（p1）** | N/A | O(1) 平均 / O(n) 最坏 | O(1) 平均 / O(n) 最坏 | O(1) 平均 / O(n) 最坏 | O(n + m)，m=997 |
| **队列（p5）** | O(1)（按下标） | O(n)（线性扫描） | O(1) 入队 | O(1) 出队 | O(n) |
| **小根堆（p7）** | O(1)（仅堆顶） | O(n) | O(log n) | O(log n)（取最小值） | O(n) |
| **邻接矩阵（p8）** | O(1)（查询边） | O(V)（邻接点） | O(1) 添加边 | O(1) 删除边 | O(V²) |

### 空间使用细节

| 项目 | 主要结构 | 实际大小 | 说明 |
| --- | --- | --- | --- |
| P1 | 哈希表 + 拉链 | ~4KB + 数据 | 997 个指针 + 链表结点 |
| P5 | 三个数组 | 12KB | 3 × 1000 个整数 |
| P7 | 堆数组 | 可变 | 动态：(n+5) × 8 字节 |
| P8 | 邻接矩阵 | 40KB | 100² 个整数 |
| P8 | 顶点名称 | 5KB | 100 × 50 个字符 |
| P10 | 排序数组 | 最大 400KB | 100,000 个整数 |

### 操作次数：典型用法

```

```

**来源：** [p1/p1.cpp L122-L492](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L122-L492)

 [p5/bank_service.cpp L18-L124](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L18-L124)

 [p7/p7.cpp L11-L111](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L11-L111)

 [p8/p8.cpp L169-L311](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L169-L311)

---

## 结构选择指南

### 何时使用各结构

| 数据结构 | 适用场景 | 不适用场景 |
| --- | --- | --- |
| **哈希表** | 按唯一键快速查找<br />平均 O(1) 操作<br />无需有序 | 需要有序遍历<br />内存受限<br />数据量很小（&lt;100） |
| **数组队列** | 简单 FIFO 处理<br />容量固定<br />顺序访问 | 需要优先级<br />需要动态扩容<br />需要随机访问 |
| **小根堆** | 优先队列<br />反复取最小值<br />合并类操作 | 同时需要最大/最小<br />频繁任意删除<br />按值查找 |
| **邻接矩阵** | 稠密图（E ≈ V²）<br />快速查询边<br />顶点集合固定 | 稀疏图<br />顶点动态变化<br />大规模图（>1000 顶点） |

### 项目级设计决策

**项目 1（哈希表）：**

* 选择 997 个桶（质数）以改善分布
* 拉链法能更平滑地处理冲突
* 以更多内存（约 4KB 指针）换取 O(1) 查找

**项目 5（队列）：**

* 两个独立队列即可满足题意，无需引入优先队列复杂度
* 1000 的固定容量在该问题域内可接受
* 简单下标推进避免循环队列的额外开销

**项目 7（堆）：**

* 1 基下标可简化父子结点的算术关系
* 动态分配适配可变规模输入
* 小根堆天然支持“取两最小再合并”的操作

**项目 8（邻接矩阵）：**

* 矩阵适合小规模、稠密图（≤100 个顶点）
* O(1) 边查询对 Prim 内层循环非常关键
* 对称存储满足无向图需求

**来源：** [p1/p1.cpp L16-L128](https://github.com/lilong555/DataStruct/blob/660fbbaa/p1/p1.cpp#L16-L128)

 [p5/bank_service.cpp L7](https://github.com/lilong555/DataStruct/blob/660fbbaa/p5/bank_service.cpp#L7-L7)

 [p7/p7.cpp L86](https://github.com/lilong555/DataStruct/blob/660fbbaa/p7/p7.cpp#L86-L86)

 [p8/p8.cpp L5-L6](https://github.com/lilong555/DataStruct/blob/660fbbaa/p8/p8.cpp#L5-L6)
