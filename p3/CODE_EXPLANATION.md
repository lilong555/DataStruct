# 迷宫游戏代码详解

## 一、代码结构

### 1. 头文件引入
```cpp
#include <iostream>   // 标准输入输出
#include <cmath>      // 数学函数（题目要求）
#include <cstring>    // 内存操作函数（用于数组初始化）
```

### 2. 常量定义
```cpp
const int kMaxSize = 100;       // 迷宫最大尺寸
const int kDirections = 4;      // 移动方向数量（四个方向）
const int kDx[4] = {0, 1, 0, -1};  // x方向偏移量：右、下、左、上
const int kDy[4] = {1, 0, -1, 0};  // y方向偏移量：右、下、左、上
```

**命名规范说明**：
- 常量使用`k`前缀 + PascalCase（Google规范）
- 数组使用下划线结尾

---

## 二、核心数据结构

### Position结构体
```cpp
struct Position {
    int x;          // 行坐标
    int y;          // 列坐标  
    int direction;  // 到达该点时的前进方向
};
```

**作用**：保存路径中每个点的位置和方向信息，便于回溯时恢复状态。

---

## 三、Maze类设计

### 成员变量（私有）
```cpp
int maze_[kMaxSize][kMaxSize];           // 迷宫地图（0通路，1墙壁）
bool visited_[kMaxSize][kMaxSize];       // 访问标记（防止重复访问）
Position path_[kMaxSize * kMaxSize];     // 路径栈（保存搜索路径）
int rows_, cols_;                         // 迷宫行列数
int start_x_, start_y_;                   // 起点坐标
int end_x_, end_y_;                       // 终点坐标
int path_length_;                         // 当前路径长度
```

**命名规范**：
- 私有成员变量使用下划线后缀（Google规范）
- 使用小写字母和下划线分隔（snake_case）

### 公共方法
1. **InputMaze()** - 输入迷宫数据
2. **SolveMaze()** - 求解迷宫（调用DFS）
3. **PrintPath()** - 打印路径坐标序列
4. **PrintMaze()** - 打印可视化地图

### 私有方法
1. **IsValid(int x, int y)** - 检查位置是否可达
2. **DFS(int x, int y)** - 深度优先搜索核心算法

---

## 四、核心算法：DFS回溯

### 算法流程

```
DFS(当前位置x, y):
    1. 如果到达终点：
        - 记录终点位置
        - 返回true
    
    2. 标记当前位置已访问
    
    3. 将当前位置加入路径
    
    4. 对四个方向依次尝试：
        for 方向 in [右, 下, 左, 上]:
            计算下一个位置(next_x, next_y)
            
            if 下一个位置有效（在范围内、未访问、非障碍）:
                记录前进方向
                path_length++
                
                if DFS(next_x, next_y) 成功:
                    返回true  // 找到路径
                
                // 回溯：撤销本次尝试
                path_length--
    
    5. 回溯：取消当前位置的访问标记
    
    6. 返回false  // 此路不通
```

### 关键点说明

#### 1. 访问标记
```cpp
visited_[x][y] = true;  // 防止走重复路径
```

#### 2. 路径记录
```cpp
path_[path_length_].x = x;
path_[path_length_].y = y;
path_[path_length_].direction = dir;
```

#### 3. 回溯操作
```cpp
path_length_--;           // 撤销路径
visited_[x][y] = false;   // 取消标记（重要！）
```
**为什么要取消标记？**  
因为这个位置可能是其他路径的一部分。如果不取消标记，可能导致遗漏正确路径。

---

## 五、输入输出格式

### 输入格式
```
第1行：rows cols（迷宫行数和列数）
第2~rows+1行：迷宫地图（0=通路，1=墙壁）
第rows+2行：start_x start_y（起点坐标，从0开始）
第rows+3行：end_x end_y（终点坐标，从0开始）
```

### 输出格式
1. **迷宫地图**：可视化展示，标记路径
   - `#` = 墙壁
   - `o` = 空地
   - `x` = 路径

2. **路径序列**：
   ```
   (1,1) ---> (2,1) ---> (3,1) ---> ...
   ```
   注意：输出时坐标+1（转为1-indexed，符合人类习惯）

---

## 六、Google C++编码规范应用

### 1. 命名规范
- **类名**：PascalCase（Maze）
- **函数名**：PascalCase（InputMaze, SolveMaze）
- **变量名**：snake_case + 下划线后缀（rows_, cols_）
- **常量**：k前缀 + PascalCase（kMaxSize）

### 2. 代码格式
- 使用2空格缩进
- 函数参数后的括号不加空格
- 控制语句（if/for）后的括号前加空格
- 运算符两侧加空格

### 3. 注释规范
- 类和函数使用Doxygen风格注释
- 复杂逻辑添加行内注释
- 每个文件开头有简要说明

### 4. 内存管理
- 使用memset初始化数组
- 固定大小数组避免动态分配

---

## 七、算法复杂度分析

### 时间复杂度
- **最坏情况**：O(4^(m×n))
  - m×n个格子，每个格子最多4个方向
  - 实际运行中由于visited标记，会远小于此值
  
- **最好情况**：O(m+n)
  - 直接找到最短路径

### 空间复杂度
- **O(m×n)**
  - maze数组：m×n
  - visited数组：m×n
  - path数组：最多m×n个元素
  - 递归栈深度：最多m×n

---

## 八、可能的改进方向

1. **优先搜索策略**
   - 当前按固定顺序（右下左上）搜索
   - 可改为启发式搜索（如A*算法），优先朝终点方向

2. **最短路径**
   - 当前找到第一条路径即停止
   - 可继续搜索，比较所有路径，找最短路径

3. **多解显示**
   - 显示所有可能的路径

4. **性能优化**
   - 使用BFS替代DFS（BFS天然找到最短路径）
   - 双向搜索（从起点和终点同时搜索）

5. **扩展功能**
   - 支持文件输入输出
   - 图形界面显示
   - 动画演示搜索过程

---

## 九、测试建议

### 测试用例设计
1. **基本功能测试**
   - 存在解的简单迷宫
   - 存在解的复杂迷宫
   
2. **边界情况测试**
   - 起点即终点
   - 起点或终点是墙壁
   - 1×1迷宫
   - 100×100大迷宫
   
3. **特殊情况测试**
   - 无解迷宫（起点和终点分离）
   - 多解迷宫（检查是否能找到一个解）
   - 全是通路的迷宫
   - 只有一条路的迷宫

---

## 十、常见问题解答

### Q1: 为什么输出坐标要+1？
**A**: 程序内部使用0-indexed（从0开始），但为了符合人类阅读习惯（题目示例是从1开始），输出时转换为1-indexed。

### Q2: 为什么回溯时要取消visited标记？
**A**: 因为某个位置在当前路径不通，但可能在其他路径中是必经之路。取消标记使其在其他搜索路径中可用。

### Q3: 如何保证找到最短路径？
**A**: 当前算法不保证最短路径，只保证找到一条路径。如需最短路径，应使用BFS算法。

### Q4: 能否处理对角线移动？
**A**: 当前只支持上下左右四方向。若需支持对角线，将kDirections改为8，并添加对应的偏移量即可。
